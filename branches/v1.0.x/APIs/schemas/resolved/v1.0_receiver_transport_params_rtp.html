---
layout: default
title: Schema v1.0_receiver_transport_params_rtp.json
---

<html>
<meta charset="UTF-8">
<h2>Schema v1.0_receiver_transport_params_rtp.json</h2>
<p>
    <a href="../../schemas/with-refs/v1.0_receiver_transport_params_rtp.html">Show original (referenced schemas with $ref)</a>
</p>
<div id="json-render">
<script type="text/javascript" src="codemirror/lib/codemirror.js"></script>
<link rel="stylesheet" href="codemirror/lib/codemirror.css">
<link rel="stylesheet" href="codemirror/addon/fold/foldgutter.css">
<script src="codemirror/mode/javascript/javascript.js"></script>
<script src="codemirror/addon/fold/foldcode.js"></script>
<script src="codemirror/addon/fold/foldgutter.js"></script>
<script src="codemirror/addon/fold/brace-fold.js"></script>
<script src="codemirror/addon/fold/indent-fold.js"></script>

<style>
  .CodeMirror {
    border-top: 1px solid black; 
    border-bottom: 1px solid black;
    height: 500px;
  }
</style>

<textarea id="mytextarea">
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "Describes RTP Receiver transport parameters. The constraints in this schema are minimum constraints, but may be further constrained at the constraints endpoint. Receivers must support at least the `source_ip`, `interface_ip`, `rtp_enabled` and `destination_port` parameters, and must support the `multicast_ip` parameter if they are capable of multicast operation. Receivers supporting FEC and/or RTCP must support parameters prefixed with `fec` and `rtcp` respectively.",
    "items": {
        "properties": {
            "destination_port": {
                "description": "destination port for RTP packets (auto = 5004 by default)",
                "maximum": 65535,
                "minimum": 1,
                "pattern": "^auto$",
                "type": [
                    "integer",
                    "string"
                ]
            },
            "fec1D_destination_port": {
                "description": "destination port for RTP Column FEC packets (auto = RTP destination_port + 2 by default)",
                "maximum": 65535,
                "minimum": 1,
                "pattern": "^auto$",
                "type": [
                    "integer",
                    "string"
                ]
            },
            "fec2D_destination_port": {
                "description": "destination port for RTP Row FEC packets (auto = RTP destination_port + 4 by default)",
                "maximum": 65535,
                "minimum": 1,
                "pattern": "^auto$",
                "type": [
                    "integer",
                    "string"
                ]
            },
            "fec_destination_ip": {
                "anyOf": [
                    {
                        "format": "ipv4"
                    },
                    {
                        "format": "ipv6"
                    },
                    {
                        "pattern": "^auto$"
                    }
                ],
                "description": "May be used if NAT is being used at the destination (auto = multicast_ip (multicast mode) or interface_ip (unicast mode) by default)",
                "type": "string"
            },
            "fec_enabled": {
                "description": "FEC on/off",
                "type": "boolean"
            },
            "fec_mode": {
                "description": "forward error correction mode to apply. (auto = highest available number of dimensions by default)",
                "enum": [
                    "auto",
                    "1D",
                    "2D"
                ],
                "type": "string"
            },
            "interface_ip": {
                "anyOf": [
                    {
                        "format": "ipv4"
                    },
                    {
                        "format": "ipv6"
                    },
                    {
                        "pattern": "^auto$"
                    }
                ],
                "description": "IP address of the network interface the receiver should use. The receiver should provide an enum in the constraints endpoint, which should contain the available interface addresses. If set to auto in multicast mode the receiver should determine which interface to use for itself, for example by using the routing tables. The behaviour of auto is undefined in unicast mode, and controllers should supply a specific interface address.",
                "type": "string"
            },
            "multicast_ip": {
                "anyOf": [
                    {
                        "format": "ipv4"
                    },
                    {
                        "format": "ipv6"
                    },
                    {
                        "type": "null"
                    }
                ],
                "description": "IP multicast group address used in multicast operation only. Should be set to null during unicast operation. A null value indicates the parameter has not been configured, or the receiver is operating in unicast mode.",
                "type": [
                    "string",
                    "null"
                ]
            },
            "rtcp_destination_ip": {
                "anyOf": [
                    {
                        "format": "ipv4"
                    },
                    {
                        "format": "ipv6"
                    },
                    {
                        "pattern": "^auto$"
                    }
                ],
                "description": "Destination IP address of RTCP packets (auto = multicast_ip (multicast mode) or interface_ip (unicast mode) by default)",
                "type": "string"
            },
            "rtcp_destination_port": {
                "description": "destination port for RTCP packets (auto = RTP destination_port + 1 by default)",
                "maximum": 65535,
                "minimum": 1,
                "pattern": "^auto$",
                "type": [
                    "integer",
                    "string"
                ]
            },
            "rtcp_enabled": {
                "description": "RTCP on/off",
                "type": "boolean"
            },
            "rtp_enabled": {
                "description": "RTP reception active/inactive",
                "type": "boolean"
            },
            "source_ip": {
                "anyOf": [
                    {
                        "format": "ipv4"
                    },
                    {
                        "format": "ipv6"
                    },
                    {
                        "type": "null"
                    }
                ],
                "description": "Source IP address of RTP packets in unicast mode, source filter for source specific multicast. A null value indicates that the source IP address has not been configured in unicast mode, or the Receiver is in any-source multicast mode.",
                "type": [
                    "string",
                    "null"
                ]
            }
        },
        "title": "Receiver Input",
        "type": "object"
    },
    "title": "RTP Receiver Transport Parameters",
    "type": "array"
}
</textarea>
<script>
window.editor_json = CodeMirror.fromTextArea(mytextarea, {
    mode: {
        name: "javascript",
        json: true
    },
    readOnly: true,
    lineNumbers: false,
    lineWrapping: true,
    extraKeys: {"Ctrl-Q": function(cm){ cm.foldCode(cm.getCursor()); }},
    foldGutter: true,
    gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
    foldOptions: {
      widget: (from, to) => {
        var count = undefined;

        // Get open / close token
        var startToken = '{', endToken = '}';
        var prevLine = window.editor_json.getLine(from.line);
        if (prevLine.lastIndexOf('[') > prevLine.lastIndexOf('{')) {
          startToken = '[', endToken = ']';
        }

        // Get json content
        var internal = window.editor_json.getRange(from, to);
        var toParse = startToken + internal + endToken;

        // Get key count
        try {
          var parsed = JSON.parse(toParse);
          count = Object.keys(parsed).length;
        } catch(e) { }

        return count ? `\u21A4${count}\u21A6` : '\u2194';
        }
      }
    }
  );
editor_json.
editor_json.foldCode(CodeMirror.Pos(3, 0));
</script>
</div>
</html>
